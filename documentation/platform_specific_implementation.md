# Platform-Specific Implementations

This document details how the FlightCanvas Terrain plugin is implemented for different platforms, focusing on the Android and iOS implementations.

## Overview

The FlightCanvas Terrain plugin includes platform-specific implementations for Android and iOS. While the core functionality (LERC decoding) is implemented in cross-platform C++, each platform requires specific integration techniques to:

1. Build the native code for the platform
2. Package the native libraries with the application
3. Load the libraries at runtime
4. Handle platform-specific memory management and lifecycle

## Android Implementation

### Build System Integration

Android integration uses the Gradle build system with NDK (Native Development Kit) support:

#### 1. build.gradle.kts (Plugin Level)

```kotlin
android {
    // Standard Android configuration
    compileSdk = 33
    ndkVersion = "25.2.9519653"

    defaultConfig {
        minSdkVersion = 21
        targetSdkVersion = 33

        // Configure native build
        externalNativeBuild {
            cmake {
                arguments += listOf(
                    "-DANDROID_STL=c++_shared"
                )
            }
        }

        // Specify which ABIs to build for
        ndk {
            abiFilters += listOf("armeabi-v7a", "arm64-v8a", "x86", "x86_64")
        }
    }

    // Point to the CMake build file
    externalNativeBuild {
        cmake {
            path = file("../CMakeLists.txt")
        }
    }
}
```

Key aspects:
- NDK version specification for compatibility
- ABI filter configuration for supported architectures
- Reference to the CMake build file in the project root
- C++ STL selection (c++_shared)

### Native Library Packaging

Android packages native libraries in a specific structure within the APK:

```
android/app/src/main/jniLibs/
├── arm64-v8a/
│   └── liblerc_wrapper.so
├── armeabi-v7a/
│   └── liblerc_wrapper.so
├── x86/
│   └── liblerc_wrapper.so
└── x86_64/
│   └── liblerc_wrapper.so
```

This structure is generated by CMake with output paths configured in the main `CMakeLists.txt`:

```cmake
if(ANDROID)
    set_target_properties(lerc_wrapper PROPERTIES
        LIBRARY_OUTPUT_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/android/app/src/main/jniLibs/${ANDROID_ABI}"
        OUTPUT_NAME "lerc_wrapper"
        PREFIX "lib"
    )
```

### Library Loading

The library is loaded in Dart code using the FFI API:

```dart
if (Platform.isAndroid) {
    libraryPath = 'liblerc_wrapper.so';
    _dylib = DynamicLibrary.open(libraryPath);
}
```

Android's library loading:
- Uses the simple name without path (Android's loader finds the library)
- Automatically selects the correct ABI version for the device
- Handles the library search path internally

### Android-Specific Considerations

1. **ABI Compatibility**:
   - The plugin builds for multiple ABIs to ensure compatibility across devices
   - This increases APK size but maximizes compatibility

2. **Library Dependencies**:
   - Android requires all dependent libraries to be included
   - The C++ shared STL is packaged with the application

3. **Performance**:
   - Android devices have varying performance characteristics
   - The code includes throttling mechanisms to adapt to device capabilities

## iOS Implementation

### Native Library Building

iOS uses a custom build process defined in `compile_lerc_ios.sh`:

```bash
#!/bin/bash

# Exit on error
set -e

echo "Compiling LERC library for iOS..."

# Define iOS architectures
ARCHS="arm64 x86_64"
DEVELOPER=$(xcode-select -print-path)
IPHONEOS_SDK_VERSION=$(xcrun -sdk iphoneos --show-sdk-version)

# ... [setup code] ...

# Compile library for each architecture
for ARCH in $ARCHS; do
  echo "Compiling for $ARCH..."
  
  if [[ "$ARCH" == "arm64" ]]; then
    SDK=$IPHONEOS_SDK
    PLATFORM="iphoneos"
  else
    SDK=$IPHONESIMULATOR_SDK
    PLATFORM="iphonesimulator"
  fi
  
  # Compile each source file
  for SRC in "${LERC_SOURCES[@]}"; do
    OBJ="${ARCH_BUILD_DIR}/$(basename ${SRC%.cpp}).o"
    xcrun -sdk $PLATFORM clang++ -c $SRC -o $OBJ $ARCH_FLAGS -std=c++14 -DLERC_STATIC \
      -I"${LERC_SRC}/LercLib" -I"${LERC_SRC}/LercLib/include" -I"${LERC_SRC}/LercLib/Lerc1Decode"
  done
  
  # Compile wrapper
  xcrun -sdk $PLATFORM clang++ -c "Classes/LercWrapper.mm" -o "${ARCH_BUILD_DIR}/LercWrapper.o" $ARCH_FLAGS -std=c++14 \
    -I"../src" -I"${LERC_SRC}" -I"${LERC_SRC}/LercLib" -I"${LERC_SRC}/LercLib/include" -I"${LERC_SRC}/LercLib/Lerc1Decode"
  
  # Create static library
  xcrun -sdk $PLATFORM ar rcs "${ARCH_BUILD_DIR}/liblerc.a" ${ARCH_BUILD_DIR}/*.o
done

# Create fat library from all architectures
xcrun -sdk iphoneos lipo -create $(find ${BUILD_DIR} -name "liblerc.a") -output "Libraries/liblerc.a"
```

Key aspects:
- Compilation for both device (arm64) and simulator (x86_64) architectures
- Direct use of Clang++ compiler with iOS SDK
- Creation of a universal binary (fat library) using lipo
- Output of a single static library `liblerc.a`

### Objective-C++ Wrapper

iOS uses an additional Objective-C++ wrapper (`LercWrapper.mm`) to bridge C++ and Objective-C:

```objectivec++
#import "LercWrapper.h"
#import "../../src/lerc_wrapper.h"
#import "../../lerc-master/src/LercLib/include/Lerc_c_api.h"
#include <cstdio>

// C interface implementation for FFI
extern "C" {
    bool lerc_wrapper_initialize(void) {
        return [LercWrapper initialize];
    }

    LercInfo* lerc_wrapper_get_info(const uint8_t* buffer, size_t size) {
        NSData *data = [NSData dataWithBytes:buffer length:size];
        NSData *infoData = [LercWrapper getInfoFromData:data];
        if (!infoData) {
            return nullptr;
        }
        LercInfo *info = new LercInfo;
        memcpy(info, [infoData bytes], sizeof(LercInfo));
        return info;
    }
    
    // ... other C interface functions ...
}

@implementation LercWrapper
+ (BOOL)initialize {
    // iOS-specific initialization
    return YES;
}

+ (NSData *)getInfoFromData:(NSData *)data {
    // Implementation that uses NSData for Objective-C compatibility
    // ...
}

+ (NSData *)decodeData:(NSData *)data withInfo:(NSData *)infoData {
    // Implementation that returns NSData
    // ...
}
@end
```

Key features:
- C functions for FFI compatibility
- Objective-C class for iOS integration
- Conversion between C++ types and Objective-C types (NSData)
- Memory management compatible with iOS ARC (Automatic Reference Counting)

### CocoaPods Integration

The iOS implementation uses CocoaPods for integration:

```ruby
# FlightCanvasLercWrapper.podspec
Pod::Spec.new do |s|
  s.name             = 'FlightCanvasLercWrapper'
  s.version          = '0.1.0'
  s.summary          = 'LERC wrapper for FlightCanvas terrain rendering'
  s.description      = 'LERC decoder implementation for terrain elevation data'
  s.homepage         = 'https://example.com'
  s.license          = { :file => '../LICENSE' }
  s.author           = { 'Your Company' => 'email@example.com' }
  s.source           = { :path => '.' }
  s.source_files     = 'Classes/**/*'
  s.vendored_libraries = 'Libraries/liblerc.a'
  s.dependency 'Flutter'
  s.platform = :ios, '12.0'
  s.pod_target_xcconfig = { 'DEFINES_MODULE' => 'YES' }
  s.swift_version = '5.0'
end
```

Key CocoaPods configuration:
- Includes the static library as a vendored library
- Defines source files for the Objective-C++ wrapper
- Sets minimum iOS version and Swift version
- Configures module definitions for proper importing

### Library Loading

The iOS library is loaded differently from Android:

```dart
if (Platform.isIOS) {
    libraryPath = 'lerc_wrapper';
    _dylib = DynamicLibrary.process();
    
    // If using the simple plugin, initialize it
    if (_useSimplePlugin) {
        try {
            final simplePluginInit = _dylib!
                .lookupFunction<Void Function(), void Function()>(
                  'lerc_wrapper_plugin_init',
                );
            simplePluginInit();
        } catch (e) {
            debugPrint('Simple plugin not available: $e');
        }
    }
}
```

iOS library loading:
- Uses `DynamicLibrary.process()` to access symbols in the main process
- The library is statically linked into the application binary
- Has an optional simple plugin initialization path

### iOS-Specific Considerations

1. **Bitcode**:
   - Compiled with `-fembed-bitcode` for App Store compliance
   - Enables Apple to optimize the binary for specific devices

2. **Architecture Support**:
   - Builds for arm64 (devices) and x86_64 (simulator)
   - Universal binary for development and deployment

3. **Memory Management**:
   - Uses Objective-C's ARC for Objective-C objects
   - Manual memory management for C++ objects
   - Careful conversion between the two domains

## Common Strategies Across Platforms

Despite the platform differences, several strategies are common to both implementations:

### 1. Error Handling

Both platforms implement robust error handling:

```dart
// Platform-agnostic error handling
try {
    // Platform-specific implementation
    initSuccess = true;
} catch (e) {
    lastError = e is Exception ? e : Exception(e.toString());
    debugPrint('Initialization attempt ${retries + 1} failed: $e');
    await Future.delayed(Duration(milliseconds: 500));
    retries++;
}
```

### 2. Feature Detection

The code includes feature detection to handle platform differences:

```dart
// Platform detection
if (Platform.isAndroid) {
    // Android-specific code
} else if (Platform.isIOS) {
    // iOS-specific code
} else {
    throw UnsupportedError('This app only supports Android and iOS platforms');
}
```

### 3. Resource Management

Both platforms carefully manage native resources:

```dart
// Clean up resources
try {
    // Use resources
} finally {
    malloc.free(inputPtr);
    if (infoPtr != nullptr) {
        bindings.lerc_wrapper_free_info(infoPtr);
    }
    if (dataPtr != nullptr) {
        bindings.lerc_wrapper_free_data(dataPtr);
    }
}
```

## Platform-Specific Debugging

### Android Debugging

1. **Native Debugging**:
   - Android Studio's LLDB debugger
   - Logcat for native logs (`__android_log_print`)
   - Systrace for performance analysis

2. **Symbols**:
   - Debug builds include symbols
   - Release builds can use symbol files

### iOS Debugging

1. **Native Debugging**:
   - Xcode's LLDB debugger
   - Console app for log messages
   - Instruments for performance profiling

2. **Memory Analysis**:
   - Instruments' Allocations tool
   - Leaks instrument for memory leak detection

## Performance Comparison

Performance characteristics differ between platforms:

| Aspect | Android | iOS |
|--------|---------|-----|
| Library Loading | Dynamic loading at runtime | Static linking at build time |
| Threading | Handled by Dart isolates | Handled by Dart isolates |
| Memory Access | Direct pointer access | NSData-mediated in Obj-C layer |
| Optimization | NDK compiler optimizations | LLVM optimizations |

## Conclusion

The platform-specific implementations for Android and iOS share the same core C++ code but use different approaches for integration with the respective platforms. The Android implementation uses dynamic libraries and JNI integration, while the iOS implementation uses static libraries and Objective-C++ wrappers. Both approaches maintain a consistent API for the Dart FFI interface, allowing the Flutter application to work seamlessly across platforms.

The careful handling of platform differences ensures that the FlightCanvas Terrain plugin provides consistent functionality and performance on both major mobile platforms while respecting their unique architectural constraints and best practices.